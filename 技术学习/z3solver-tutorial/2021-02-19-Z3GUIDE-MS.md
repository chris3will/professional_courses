# 2021-02-19-Z3GUIDE-MS

https://rise4fun.com/z3/tutorialcontent/guide

z3功能强大，可以用来检测不同领域下逻辑公式的可满足性问题。

不同于其他工具是专门为某个领域设计生产的，z3 提供了一种跟灵活的方式，为软件分析与验证服务。



这篇tutorial重在教一些使用范例，侧重点不在一阶逻辑的原理

---

![image-20210219084718518](2021-02-19-Z3GUIDE-MS.assets/image-20210219084718518.png)

check state是保证程序能得到结果的关键一步



一个关于声明函数的帖子

https://stackoverflow.com/questions/11883185/z3py-declaring-function

```python
from z3 import *

x=Int('x')
c=Int('c')
t=Int('t')

s=Solver()

f = Function('f', IntSort(), IntSort())

# x*t+c = result
# x, result = [(1,55), (12,34), (13,300)]

s.add (f(x)==(x*t+c))
s.add (f(1)==55, f(12)==34, f(13)==300)

t=s.check()
if t==sat:
    print s.model()
else:
   print t
```

上面这个案例是想求解参数t和x，但实际上应该对z3的规则定义有误解，帖子下面跟了解答

```python
from z3 import *

c=Int('c')
t=Int('t')

def f(x):
    return x*t + c

# data is a list of pairs (x, r)
def find(data):
    s=Solver()
    s.add([ f(x) == r for (x, r) in data ])
    t = s.check()
    if s.check() == sat:
        print s.model()
    else:
        print t

find([(1, 55)])
find([(1, 55), (12, 34)])
find([(1, 55), (12, 34), (13, 300)])
```

这个人的理解就很直接，并不意味着非要用z3的语句来定义函数，就用python来定义函数。然后中间不断矗立着数据，也是可以的

有一句话挺关键的：'Z3 supports universal quantifiers(用于断言所陈述的普遍命题对所描述的宇宙或类的所有成员都是正确的形式表达). However, they are very expensive, and Z3 is not complete when a set of constraints contains universal quantifiers since the problem becomes undecidable. '

所以说，这个人就是因为引入全局量词可能的成本太高，所以避免了这样的引入，但实际上应该是定义的问题。他没有讲俺很想知道的这个事情。



---

实际上z3的函数定义就是形如：

f = Function('f', IntSort(), IntSort()) # 目前个人对这个的理解是，定义一个返回值类型为Int的函数f，参数包含一个，是Int类型的

类似与这样，同样是前缀表达式，话不多说，先试试

---

## API的使用，肯定是基础

![image-20210219094555401](2021-02-19-Z3GUIDE-MS.assets/image-20210219094555401.png)

可以更多的把sort理解为type的含义

![image-20210219100034605](2021-02-19-Z3GUIDE-MS.assets/image-20210219100034605.png)

注意，这是个参数列表



但是我还是没能理解多参数复杂函数的定义模式



---



## z3py的tutorial

https://ericpony.github.io/z3py-tutorial/guide-examples.htm

虽然是python2，但是最好直接上手，于是先跟这个学

这是最简单的一个例子的展现

![image-20210219102718918](2021-02-19-Z3GUIDE-MS.assets/image-20210219102718918.png)

写的不规范（加空格）也不要紧，又simplify这个函数可以帮忙

![image-20210219102948180](2021-02-19-Z3GUIDE-MS.assets/image-20210219102948180.png)

同样，顾名思义，也可以起到化简的作用

为traversing expression提供函数，即遍历，（有很多工具不提供遍历的方式吗？

![image-20210219103403839](2021-02-19-Z3GUIDE-MS.assets/image-20210219103403839.png)

注意赋值方式 将整个表达式“x+y >=3"赋值给了n

![image-20210219103927226](2021-02-19-Z3GUIDE-MS.assets/image-20210219103927226.png)

一个表达式，每一部分都是一个组成环节，可以调用这个库去查看名字

![image-20210219104219593](2021-02-19-Z3GUIDE-MS.assets/image-20210219104219593.png)

real可以表达各种数学状态，整数类型，有理数类型，非有理数的代数也可以。带有整数系数的多项式根可以是一个非有理数

当然也有布尔形式的

![image-20210219155523187](2021-02-19-Z3GUIDE-MS.assets/image-20210219155523187.png)

![image-20210219155837120](2021-02-19-Z3GUIDE-MS.assets/image-20210219155837120.png)

![image-20210219155846320](2021-02-19-Z3GUIDE-MS.assets/image-20210219155846320.png)

这里面碰到了一个Implies函数，可能是说其参数只有一个为真

![img](2021-02-19-Z3GUIDE-MS.assets/%7BE0EAF378-E052-3F7B-CA54-4420B044B526%7D.jpg)

![image-20210219160020659](2021-02-19-Z3GUIDE-MS.assets/image-20210219160020659.png)

多项式与布尔表达式是可以相互结合的

---

### Solver（）



Solvers 这是z3举足轻重的一个部分，

>Z3 provides different solvers. The command `solve`, used in the previous examples, is implemented using the Z3 solver API. The implementation can be found in the file `z3.py` in the Z3 distribution. The following example demonstrates the basic Solver API.

在很多场景下，可能会有相似的问题拥有共同的约束条件，这个时候我们可以利用push 和 pop操作来对各子独特的条件进行再判断。

> The command `push` creates a new scope by saving the current stack size The command `pop` removes any assertion performed between it and the matching `push`. The `check` method always operates on the content of solver assertion stack.

再solver中添加的条件assertions也是可以进行遍历查看处理的：

![image-20210219161714330](2021-02-19-Z3GUIDE-MS.assets/image-20210219161714330.png)

![image-20210219161755396](2021-02-19-Z3GUIDE-MS.assets/image-20210219161755396.png)

> The command `check` returns `sat` when Z3 finds a solution for the set of asserted constraints. We say Z3 **satisfied** the set of constraints. We say the solution is a **model** for the set of asserted constraints. A model is an **interpretation** that makes each asserted constraint **true**. The following example shows the basic methods for inspecting models.

调用solver的model函数即得到一个约束条件全为真的一个实例

![image-20210219162348251](2021-02-19-Z3GUIDE-MS.assets/image-20210219162348251.png)

注意，打印的东西和其key分别是什么，不是传统的字典那种样子，不过看一下就能明白

不过这种方式去遍历貌似更加正统

![image-20210219162508753](2021-02-19-Z3GUIDE-MS.assets/image-20210219162508753.png)

变量的声明也有很多中形式：

![image-20210219162543911](2021-02-19-Z3GUIDE-MS.assets/image-20210219162543911.png)

---

### Arithmetic

z3 支持 real和整数型变量，也允许将他们混合再一个问题中，再有必要的时候整数型会被自动转化为real

![image-20210219163031274](2021-02-19-Z3GUIDE-MS.assets/image-20210219163031274.png)

![image-20210219163048334](2021-02-19-Z3GUIDE-MS.assets/image-20210219163048334.png)

常规的数学运算都是被z3支持的![image-20210219165115171](2021-02-19-Z3GUIDE-MS.assets/image-20210219165115171.png)

而且simplify函数还能改变这种多项式的形式

![image-20210219165453629](2021-02-19-Z3GUIDE-MS.assets/image-20210219165453629.png)

![image-20210219165850005](2021-02-19-Z3GUIDE-MS.assets/image-20210219165850005.png)

运算的中间结果也可以被表示出来，包括那些复数

The internal representation can be extracted using the method `sexpr()`. It displays Z3 internal representation for mathematical formulas and expressions in [s-expression](http://en.wikipedia.org/wiki/S-expression) (Lisp-like) notation.

![image-20210219170214821](2021-02-19-Z3GUIDE-MS.assets/image-20210219170214821.png)

当然，这如果是有需要的话

![image-20210219170307805](2021-02-19-Z3GUIDE-MS.assets/image-20210219170307805.png)

理解起来，可以说是一个前缀表达式了

### Machine Arithmetic

> Modern CPUs and main-stream programming languages use arithmetic over fixed-size bit-vectors. Machine arithmetic is available in Z3Py as *Bit-Vectors*. They implement the precise semantics of unsigned and of signed [two-complements arithmetic](http://en.wikipedia.org/wiki/Two's_complement).
>
> The following example demonstrates how to create bit-vector variables and constants. The function `BitVec('x', 16)` creates a bit-vector variable in Z3 named `x` with `16` bits. For convenience, integer constants can be used to create bit-vector expressions in Z3Py. The function `BitVecVal(10, 32)` creates a bit-vector of size `32` containing the value `10`.

现代计算机通常用定长的向量来进行计算，这个例子介绍了如何使用比特向量进行工作。