# 2021-02-19-Z3GUIDE-MS

https://rise4fun.com/z3/tutorialcontent/guide

z3功能强大，可以用来检测不同领域下逻辑公式的可满足性问题。

不同于其他工具是专门为某个领域设计生产的，z3 提供了一种跟灵活的方式，为软件分析与验证服务。



这篇tutorial重在教一些使用范例，侧重点不在一阶逻辑的原理

---

![image-20210219084718518](2021-02-19-Z3GUIDE-MS.assets/image-20210219084718518.png)

check state是保证程序能得到结果的关键一步



一个关于声明函数的帖子

https://stackoverflow.com/questions/11883185/z3py-declaring-function

```python
from z3 import *

x=Int('x')
c=Int('c')
t=Int('t')

s=Solver()

f = Function('f', IntSort(), IntSort())

# x*t+c = result
# x, result = [(1,55), (12,34), (13,300)]

s.add (f(x)==(x*t+c))
s.add (f(1)==55, f(12)==34, f(13)==300)

t=s.check()
if t==sat:
    print s.model()
else:
   print t
```

上面这个案例是想求解参数t和x，但实际上应该对z3的规则定义有误解，帖子下面跟了解答

```python
from z3 import *

c=Int('c')
t=Int('t')

def f(x):
    return x*t + c

# data is a list of pairs (x, r)
def find(data):
    s=Solver()
    s.add([ f(x) == r for (x, r) in data ])
    t = s.check()
    if s.check() == sat:
        print s.model()
    else:
        print t

find([(1, 55)])
find([(1, 55), (12, 34)])
find([(1, 55), (12, 34), (13, 300)])
```

这个人的理解就很直接，并不意味着非要用z3的语句来定义函数，就用python来定义函数。然后中间不断矗立着数据，也是可以的

有一句话挺关键的：'Z3 supports universal quantifiers(用于断言所陈述的普遍命题对所描述的宇宙或类的所有成员都是正确的形式表达). However, they are very expensive, and Z3 is not complete when a set of constraints contains universal quantifiers since the problem becomes undecidable. '

所以说，这个人就是因为引入全局量词可能的成本太高，所以避免了这样的引入，但实际上应该是定义的问题。他没有讲俺很想知道的这个事情。



---

实际上z3的函数定义就是形如：

f = Function('f', IntSort(), IntSort()) # 目前个人对这个的理解是，定义一个返回值类型为Int的函数f，参数包含一个，是Int类型的

类似与这样，同样是前缀表达式，话不多说，先试试

---

## API的使用，肯定是基础

![image-20210219094555401](2021-02-19-Z3GUIDE-MS.assets/image-20210219094555401.png)

可以更多的把sort理解为type的含义

![image-20210219100034605](2021-02-19-Z3GUIDE-MS.assets/image-20210219100034605.png)

注意，这是个参数列表



但是我还是没能理解多参数复杂函数的定义模式



---



## z3py的tutorial

https://ericpony.github.io/z3py-tutorial/guide-examples.htm

虽然是python2，但是最好直接上手，于是先跟这个学

这是最简单的一个例子的展现

![image-20210219102718918](2021-02-19-Z3GUIDE-MS.assets/image-20210219102718918.png)

写的不规范（加空格）也不要紧，又simplify这个函数可以帮忙

![image-20210219102948180](2021-02-19-Z3GUIDE-MS.assets/image-20210219102948180.png)

同样，顾名思义，也可以起到化简的作用

为traversing expression提供函数，即遍历，（有很多工具不提供遍历的方式吗？

![image-20210219103403839](2021-02-19-Z3GUIDE-MS.assets/image-20210219103403839.png)

注意赋值方式 将整个表达式“x+y >=3"赋值给了n

![image-20210219103927226](2021-02-19-Z3GUIDE-MS.assets/image-20210219103927226.png)

一个表达式，每一部分都是一个组成环节，可以调用这个库去查看名字

![image-20210219104219593](2021-02-19-Z3GUIDE-MS.assets/image-20210219104219593.png)

real可以表达各种数学状态，整数类型，有理数类型，非有理数的代数也可以。带有整数系数的多项式根可以是一个非有理数

当然也有布尔形式的

![image-20210219155523187](2021-02-19-Z3GUIDE-MS.assets/image-20210219155523187.png)

![image-20210219155837120](2021-02-19-Z3GUIDE-MS.assets/image-20210219155837120.png)

![image-20210219155846320](2021-02-19-Z3GUIDE-MS.assets/image-20210219155846320.png)

这里面碰到了一个Implies函数，可能是说其参数只有一个为真

![img](2021-02-19-Z3GUIDE-MS.assets/%7BE0EAF378-E052-3F7B-CA54-4420B044B526%7D.jpg)

![image-20210219160020659](2021-02-19-Z3GUIDE-MS.assets/image-20210219160020659.png)

多项式与布尔表达式是可以相互结合的

---

### Solver（）



Solvers 这是z3举足轻重的一个部分，

>Z3 provides different solvers. The command `solve`, used in the previous examples, is implemented using the Z3 solver API. The implementation can be found in the file `z3.py` in the Z3 distribution. The following example demonstrates the basic Solver API.

在很多场景下，可能会有相似的问题拥有共同的约束条件，这个时候我们可以利用push 和 pop操作来对各子独特的条件进行再判断。

> The command `push` creates a new scope by saving the current stack size The command `pop` removes any assertion performed between it and the matching `push`. The `check` method always operates on the content of solver assertion stack.

再solver中添加的条件assertions也是可以进行遍历查看处理的：

![image-20210219161714330](2021-02-19-Z3GUIDE-MS.assets/image-20210219161714330.png)

![image-20210219161755396](2021-02-19-Z3GUIDE-MS.assets/image-20210219161755396.png)

> The command `check` returns `sat` when Z3 finds a solution for the set of asserted constraints. We say Z3 **satisfied** the set of constraints. We say the solution is a **model** for the set of asserted constraints. A model is an **interpretation** that makes each asserted constraint **true**. The following example shows the basic methods for inspecting models.

调用solver的model函数即得到一个约束条件全为真的一个实例

![image-20210219162348251](2021-02-19-Z3GUIDE-MS.assets/image-20210219162348251.png)

注意，打印的东西和其key分别是什么，不是传统的字典那种样子，不过看一下就能明白

不过这种方式去遍历貌似更加正统

![image-20210219162508753](2021-02-19-Z3GUIDE-MS.assets/image-20210219162508753.png)

变量的声明也有很多中形式：

![image-20210219162543911](2021-02-19-Z3GUIDE-MS.assets/image-20210219162543911.png)

---

### Arithmetic

z3 支持 real和整数型变量，也允许将他们混合再一个问题中，再有必要的时候整数型会被自动转化为real

![image-20210219163031274](2021-02-19-Z3GUIDE-MS.assets/image-20210219163031274.png)

![image-20210219163048334](2021-02-19-Z3GUIDE-MS.assets/image-20210219163048334.png)

常规的数学运算都是被z3支持的![image-20210219165115171](2021-02-19-Z3GUIDE-MS.assets/image-20210219165115171.png)

而且simplify函数还能改变这种多项式的形式

![image-20210219165453629](2021-02-19-Z3GUIDE-MS.assets/image-20210219165453629.png)

![image-20210219165850005](2021-02-19-Z3GUIDE-MS.assets/image-20210219165850005.png)

运算的中间结果也可以被表示出来，包括那些复数

The internal representation can be extracted using the method `sexpr()`. It displays Z3 internal representation for mathematical formulas and expressions in [s-expression](http://en.wikipedia.org/wiki/S-expression) (Lisp-like) notation.

![image-20210219170214821](2021-02-19-Z3GUIDE-MS.assets/image-20210219170214821.png)

当然，这如果是有需要的话

![image-20210219170307805](2021-02-19-Z3GUIDE-MS.assets/image-20210219170307805.png)

理解起来，可以说是一个前缀表达式了

### Machine Arithmetic

> Modern CPUs and main-stream programming languages use arithmetic over fixed-size bit-vectors. Machine arithmetic is available in Z3Py as *Bit-Vectors*. They implement the precise semantics of unsigned and of signed [two-complements arithmetic](http://en.wikipedia.org/wiki/Two's_complement).
>
> The following example demonstrates how to create bit-vector variables and constants. The function `BitVec('x', 16)` creates a bit-vector variable in Z3 named `x` with `16` bits. For convenience, integer constants can be used to create bit-vector expressions in Z3Py. The function `BitVecVal(10, 32)` creates a bit-vector of size `32` containing the value `10`.

现代计算机通常用定长的向量来进行计算，这个例子介绍了如何使用比特向量进行工作。

整数常量可以被用来创建比特向量表达式，BitVec含有两个参数，第二个参数总是代表长度。

![image-20210219170950131](2021-02-19-Z3GUIDE-MS.assets/image-20210219170950131.png)

![image-20210219170936101](2021-02-19-Z3GUIDE-MS.assets/image-20210219170936101.png)

```
# -1 is equal to 65535 for 16-bit integers 
print simplify(x + y - 1)
```

当然， 也可以定义比特向量形式的常量

![image-20210219171108327](2021-02-19-Z3GUIDE-MS.assets/image-20210219171108327.png)

![image-20210219171643016](2021-02-19-Z3GUIDE-MS.assets/image-20210219171643016.png)

在32位的情况下，-1和65535是不相等的

> In contrast to programming languages, such as C, C++, C#, Java, there is no distinction between signed and unsigned bit-vectors as numbers. Instead, Z3 provides special signed versions of arithmetical operations where it makes a difference whether the bit-vector is treated as signed or unsigned. In Z3Py, the operators `<`, `<=`, `>`, `>=`, `/`, `%` and `>>` correspond to the signed versions. The corresponding unsigned operators are `ULT`, `ULE`, `UGT`, `UGE`, `UDiv`, `URem` and `LShR`.
>
> 

因为我目前在学习的并不着重与数学运算。所以这部分我先掠过了

---

### Functions

> Unlike programming languages, where functions have side-effects, can throw exceptions, or never return, functions in Z3 have no side-effects and are **total**. That is, they are defined on all input values. This includes functions, such as division. Z3 is based on [first-order logic](http://en.wikipedia.org/wiki/First-order_logic).

这个意思是说，函数会有全局的影响

z3的函数，是unterpreted的，拥有最高的灵活程度. 没有附加先验解释

> they allow any interpretation that is consistent with the constraints over the function or constant.

> To illustrate uninterpreted functions and constants let us the uninterpreted integer constants (aka  variables) `x`, `y`. Finally let `f` be an uninterpreted function that takes one argument of type (aka sort) integer and results in an integer value. The example illustrates how one can force an interpretation where `f` applied twice to `x` results in `x` again, but `f` applied once to `x` is different from `x`. (这段我觉得说的云里雾里的)

![image-20210219172333066](2021-02-19-Z3GUIDE-MS.assets/image-20210219172333066.png)

![image-20210219172441156](2021-02-19-Z3GUIDE-MS.assets/image-20210219172441156.png)

可以妙用solver中的evaluate函数

![image-20210220083948660](2021-02-19-Z3GUIDE-MS.assets/image-20210220083948660.png)

![image-20210220083958129](2021-02-19-Z3GUIDE-MS.assets/image-20210220083958129.png)

注意，这个输出的值，应该就是model求值时满足这种条件的时候每一个assertion的状态。

---



### Satisfiability and validity

> A formula/constraint `F` is **valid** if `F` always evaluates to true for any assignment of appropriate values to its uninterpreted symbols. A formula/constraint `F` is **satisfiable** if there is some assignment of appropriate values to its uninterpreted symbols under which `F` evaluates to true. **Validity is about finding a proof of a statement;** satisfiability is about finding a solution to a set of constraints. Consider a formula `F` containing `a` and `b`. We can ask whether `F` is valid, that is whether it is always true for any combination of values for `a` and `b`. **If `F` is always true, then `Not(F)` is always false, and then `Not(F)` will not have any satisfying assignment (i.e., solution)**; that is, `Not(F)` is unsatisfiable. That is, `F` is valid precisely when `Not(F)` is not satisfiable (is unsatisfiable). Alternately, `F` is satisfiable if and only if `Not(F)` is not valid (is invalid). The following example proves the deMorgan's law.
>
> The following example redefines the Z3Py function `prove` that receives a formula as a parameter. This function creates a solver, adds/asserts the negation of the formula, and check if the negation is unsatisfiable. The implementation of this function is a simpler version of the Z3Py command `prove`.

```python
from z3 import *

p,q = Bools('p q')
demorgan = And(p,q) == Not(Or(Not(p), Not(q)))
print(simplify(demorgan))

def prove(f):
    s = Solver()
    s.add(Not(f)) # 加入一种假设，即f不成立，去查f是否invalid在任何输入下均成立
    # print(s.check())
    if(s.check() == unsat):
        print("proved")
    else:
        print("failed to prove")

print("proving demorgan..")
prove(demorgan)    
```

![image-20210220085154731](2021-02-19-Z3GUIDE-MS.assets/image-20210220085154731.png)

正如上文中提到的，这里用了类似一种反证法，如果F恒为真，则Not（F)将恒为假，即Not（F）没有任意一组可使其为真的解决方案（solution），所以Not（F）即为unsat，unsatisfiable的状态。

---

### List Comprehensions

> Python supports [list comprehensions](http://docs.python.org/tutorial/datastructures.html#list-comprehensions). List comprehensions provide a concise way to create lists. They can be used to create Z3 expressions and problems in Z3Py. The following example demonstrates how to use Python list comprehensions in Z3Py.

或许可以理解为怎么在这里使用python list。

```python
from z3 import *

print([x+1 for x in range(5)])

#create two lists containing 5 integer variables

X = [ Int('x%s' %i)for i in range(5)]
Y = [Int('y%s' %i) for i in range(5)]

print(X)

# Create a list containing X[i] + Y[i]
X_plus_Y = [ X[i] + Y[i] for i in range(5)]
print(X_plus_Y)

# Create a list containing X[i] > Y[i]
X_gt_Y = [ X[i] > Y[i] for i in range(5)]
print(X_gt_Y)
```

![image-20210220090340335](2021-02-19-Z3GUIDE-MS.assets/image-20210220090340335.png)

可以理解为创建了各种满足你约束条件的一个列表

~~~python
# Create a 3x3 "matrix" of integer variables
X = [ [Int('x_%s_%s' % (i+1,j+1)) for j in range(3)]
        for i in range(3)]
print(X[1])
~~~

![image-20210220090826298](2021-02-19-Z3GUIDE-MS.assets/image-20210220090826298.png)

i和j的顺序到无关紧要，这个就是常规的问题

```python
from z3 import *

d,a,t,v_i,v_f = Reals('d a t v__i, v__f')

equations = [
    d == v_i * t + (a*t**2)/2,
    v_f == v_i + a*t,
]

print("Kinematic equations:")
print(equations)

# Given v_i,v_f and a, find d

problem = [
    v_i == 30,
    v_f ==0,
    a == -8
]

print("Problem:")
print(problem)

print("Solutions:")
solve(equations + problem)
```

![image-20210220093338391](2021-02-19-Z3GUIDE-MS.assets/image-20210220093338391.png)

注意，最后solve中用的使equations + problem。尝试了一下逗号，编译器直接错误。

这里面的+应该使抽象的+，是把这些条件的参数组合在一起输入进去，或者说是一种赋值

---

### Bit Tricks

貌似是说妙用bit位的运算

> Some low level [hacks](http://graphics.stanford.edu/~seander/bithacks.html) are very popular with C programmers. We use some of these hacks in the Z3 implementation.

### Power of two

This hack is frequently used in C programs (Z3 included) to test whether a machine integer is a power of two. We can use Z3 to prove it really works. The claim is that `x != 0 && !(x & (x - 1))` is true if and only if `x` is a power of two.

```python
x      = BitVec('x', 32)
powers = [ 2**i for i in range(32) ]
fast   = And(x != 0, x & (x - 1) == 0)
slow   = Or([ x == p for p in powers ])
print fast
prove(fast == slow)

print "trying to prove buggy version..."
fast   = x & (x - 1) == 0
prove(fast == slow)
```

![image-20210220094508144](2021-02-19-Z3GUIDE-MS.assets/image-20210220094508144.png)

由上图可见，prove是一个z3的内置函数，可显示proved或者不成立时把反例展示出来。

### Opposite signs

The following simple hack can be used to test whether two machine integers have opposite signs.

```python
from z3 import *

x = BitVec('x',32)
y = BitVec('y',32)

# Claim: (x^y < 0 iffx and y have opposite signs)

trick = (x^y) < 0

# Naive way to check if x and y have opposite signs
opposite = Or(And(x<0,y>=0),
And(x>=0,y<0))

prove(trick == opposite) # z3可以让我们去检测一些情况是否拥有相同的判断结果

```

![image-20210220095119031](2021-02-19-Z3GUIDE-MS.assets/image-20210220095119031.png)

---

### Puzzles

一些有趣的基础使用场景

### Dog, Cat and Mouse

Consider the following puzzle. Spend exactly 100 dollars and buy exactly 100 animals. Dogs cost 15 dollars, cats cost 1 dollar, and mice cost 25 cents each. You have to buy at least one of each. How many of each should you buy?

```python
# Create 3 integer variables
dog, cat, mouse = Ints('dog cat mouse')
solve(dog >= 1,   # at least one dog
      cat >= 1,   # at least one cat
      mouse >= 1, # at least one mouse
      # we want to buy 100 animals
      dog + cat + mouse == 100,
      # We have 100 dollars (10000 cents):
      #   dogs cost 15 dollars (1500 cents), 
      #   cats cost 1 dollar (100 cents), and 
      #   mice cost 25 cents 
      1500 * dog + 100 * cat + 25 * mouse == 10000)
```

![image-20210220095651548](2021-02-19-Z3GUIDE-MS.assets/image-20210220095651548.png)

### Sudoku

[Sudoku](http://www.dailysudoku.com/sudoku/) is a very popular puzzle. The goal is to insert the numbers in the boxes to satisfy only one condition: each row, column and `3x3` box must contain the digits `1` through `9` exactly once.

![img](2021-02-19-Z3GUIDE-MS.assets/sudoku.png)

The following example encodes the sudoku problem in Z3. Different sudoku instances can be solved by modifying the matrix `instance`. This example makes heavy use of [list comprehensions](http://docs.python.org/tutorial/datastructures.html#list-comprehensions) available in the Python programming language.

```python
# 9x9 matrix of integer variables
X = [ [ Int("x_%s_%s" % (i+1, j+1)) for j in range(9) ]
      for i in range(9) ]

# each cell contains a value in {1, ..., 9}
cells_c  = [ And(1 <= X[i][j], X[i][j] <= 9)
             for i in range(9) for j in range(9) ]

# each row contains a digit at most once
rows_c   = [ Distinct(X[i]) for i in range(9) ]

# each column contains a digit at most once
cols_c   = [ Distinct([ X[i][j] for i in range(9) ])
             for j in range(9) ]

# each 3x3 square contains a digit at most once
sq_c     = [ Distinct([ X[3*i0 + i][3*j0 + j]
                        for i in range(3) for j in range(3) ])
             for i0 in range(3) for j0 in range(3) ]

sudoku_c = cells_c + rows_c + cols_c + sq_c

# sudoku instance, we use '0' for empty cells
instance = ((0,0,0,0,9,4,0,3,0),
            (0,0,0,5,1,0,0,0,7),
            (0,8,9,0,0,0,0,4,0),
            (0,0,0,0,0,0,2,0,8),
            (0,6,0,2,0,1,0,5,0),
            (1,0,2,0,0,0,0,0,0),
            (0,7,0,0,0,0,5,2,0),
            (9,0,0,0,6,5,0,0,0),
            (0,4,0,9,7,0,0,0,0))

instance_c = [ If(instance[i][j] == 0,
                  True,
                  X[i][j] == instance[i][j])
               for i in range(9) for j in range(9) ]

s = Solver()
s.add(sudoku_c + instance_c)
if s.check() == sat:
    m = s.model()
    r = [ [ m.evaluate(X[i][j]) for j in range(9) ]
          for i in range(9) ]
    print_matrix(r)
else:
    print "failed to solve"
```



### Eight Queens

The eight queens puzzle is the problem of placing eight chess queens on an 8x8 chessboard so that no two queens attack each other. Thus, a solution requires that no two queens share the same row, column, or diagonal.

![img](2021-02-19-Z3GUIDE-MS.assets/queens.png)

```python
# We know each queen must be in a different row.
# So, we represent each queen by a single integer: the column position
Q = [ Int('Q_%i' % (i + 1)) for i in range(8) ]

# Each queen is in a column {1, ... 8 }
val_c = [ And(1 <= Q[i], Q[i] <= 8) for i in range(8) ]

# At most one queen per column
col_c = [ Distinct(Q) ]

# Diagonal constraint
diag_c = [ If(i == j,
              True,
              And(Q[i] - Q[j] != i - j, Q[i] - Q[j] != j - i))
           for i in range(8) for j in range(i) ]

solve(val_c + col_c + diag_c)
```

---

[Z3 - Guide (rise4fun.com)](https://rise4fun.com/z3/tutorialcontent/guide)

### propositional Logic

> The pre-defined sort Bool is the sort (type) of all Boolean propositional expressions. Z3 supports the usual Boolean operators `and`, `or`, `xor`, `not`, `=>` (implication), `ite` (if-then-else). Bi-implications are represented using equatity `=`. The following example shows how to prove that if `p` implies `q` and `q` implies `r`, then `p` implies `r`. We accomplish that by showing that the negation is unsatisfiable. The command define-fun is used to define a macro (aka alias). In this example, `conjecture` is an alias for the conjecture we want to prove.

```
(declare-const p Bool)
(declare-const q Bool)
(declare-const r Bool)
(define-fun conjecture () Bool
	(=> (and (=> p q) (=> q r))
		(=> p r)))
(assert (not conjecture))
(check-sat)
```

```python
from z3 import *

p,q,r = Bools('p q r')

conject = Function('conject',BoolSort())

s = Solver()

s.add(Not(Implies(conject(),(And(Implies(p,q),Implies(q,r),Implies(p,r))))))
s.check()
m = s.model()
print(m)
```

写成python就是上面的样子，

![image-20210220162854738](2021-02-19-Z3GUIDE-MS.assets/image-20210220162854738.png)

根据结果，定义的conject为false，根据蕴含的概念，此时

？ 晕，上面的这个函数还是不会写

---

[Z3Py Strategies (ericpony.github.io)](https://ericpony.github.io/z3py-tutorial/strategies-examples.htm)

## Strategies

### Introduction

> Z3 implements a methodology for orchestrating reasoning engines where "big" symbolic reasoning steps are represented as functions known as **tactics**, and tactics are composed using combinators known as **tacticals**. Tactics process sets of formulas called **Goals**.
>
> When a tactic is applied to some goal `G`, **four different outcomes are possible.** The tactic succeeds in showing `G` to be satisfiable (i.e., feasible); succeeds in showing `G` to be unsatisfiable (i.e., infeasible); produces a sequence of subgoals; or fails. When reducing a goal `G` to a sequence of subgoals `G1`, ..., `Gn`, we face the problem of model conversion. A **model converter** construct a model for `G` using a model for some subgoal `Gi`.
>
> In the following example, we create a goal `g` consisting of three formulas, and a tactic `t` composed of two built-in tactics: `simplify` and `solve-eqs`. The tactic `simplify` apply transformations equivalent to the ones found in the command `simplify`. The tactic `solver-eqs` eliminate variables using Gaussian elimination. Actually, `solve-eqs` is not restricted only to linear arithmetic. It can also eliminate arbitrary variables. Then, combinator `Then` applies `simplify` to the input goal and `solve-eqs` to each subgoal produced by `simplify`. In this example, only one subgoal is produced.

```python
from z3 import *
x,y = Reals('x y')
g = Goal()
g.add(x>0, y>0, x==y+2)
print(g)

t1 = Tactic('simplify')
t2 = Tactic('solve-eqs')
t = Then(t1,t2)
print(t(g))
```

![image-20210220164725187](2021-02-19-Z3GUIDE-MS.assets/image-20210220164725187.png)

In the example above, variable `x` is eliminated, and is not present the resultant goal.

In Z3, we say a **clause** is any constraint of the form `Or(f_1, ..., f_n)`. The tactic `split-clause` will select a clause `Or(f_1, ..., f_n)` in the input goal, and split it `n` subgoals. One for each subformula `f_i`.

这些子句各个尝试击破，即有可能得到满足条件的结果

 ```python
from z3 import *
x,y = Reals('x y')
g = Goal()
g.add(Or(x>0,x<0),x==y+1,y<0)

t = Tactic('split-clause')
r = t(g)
for gg in r:
    print(gg)
 ```

![image-20210220165057930](2021-02-19-Z3GUIDE-MS.assets/image-20210220165057930.png)

结果就分为了两行，因为其含一个或

注意：原句说的是split-clause会选 一个 or进行拆分，

```python
from z3 import *
x,y = Reals('x y')
g = Goal()
g.add(Or(x>0,x<0),x==y+1,y<0,Or(y>1,y<-1))

t = Tactic('split-clause')
r = t(g)
for gg in r:
    print(gg)
```

如果是上图的状态，也只是会拆一组

---

### Tactics

> Z3 comes equipped with many built-in tactics. The command `describe_tactics()` provides a short description of all built-in tactics.
>
> ```
> describe_tactics()
> ```
>
> 
>
> Z3Py comes equipped with the following tactic combinators (aka tacticals):
>
> - `Then(t, s)` applies `t` to the input goal and `s` to every subgoal produced by `t`.
> - `OrElse(t, s)` first applies `t` to the given goal, if it fails then returns the result of `s` applied to the given goal.
> - `Repeat(t)` Keep applying the given tactic until no subgoal is modified by it.
> - `Repeat(t, n)` Keep applying the given tactic until no subgoal is modified by it, or the number of iterations is greater than `n`.
> - `TryFor(t, ms)` Apply tactic `t` to the input goal, if it does not return in `ms` millisenconds, it fails.
> - `With(t, params)` Apply the given tactic using the given parameters.
>
> The following example demonstrate how to use these combinators.

本身z3就内置了很多好的策略机制。毕竟只有这样财富和它能应对那么多特殊场合的身份。

```python
x,y,z = Reals('x y z')
g =Goal()
g.add(Or(x==0,x==1),
    Or(y==0,y==1),
    Or(z==0,z==1),
    x+y+z>2)

# Split all clause 这里即用组合的方式展示tactics的效果
# 例如上图中有三个Or，下面要配合Repeat，OrElse，函数来执行

split_all = Repeat(OrElse(Tactic('split-clause'), Tactic('skip')))
print(split_all(g))

```

![image-20210220170907525](2021-02-19-Z3GUIDE-MS.assets/image-20210220170907525.png)

```python
split_at_most_2 = Repeat(OrElse(Tactic('split-clause'),
                Tactic('skip')),
                1)
print(split_at_most_2(g)) 
```

![image-20210220171137389](2021-02-19-Z3GUIDE-MS.assets/image-20210220171137389.png)

如图，如果做了上述修改，则会打开两次，本身一次，然后repeat1次，共有两个Or被打开

```python
split_solve= Then(Repeat(OrElse(Tactic('split-clause'),
            Tactic('skip'))),
            Tactic('solve-eqs'))
print(split_solve(g))
```

![image-20210220171512515](2021-02-19-Z3GUIDE-MS.assets/image-20210220171512515.png)

> In the tactic `split_solver`, the tactic `solve-eqs` discharges all but one goal. Note that, this tactic generates one goal: the empty goal which is trivially satisfiable (i.e., feasible)

这句话的意思应该是说，这个技巧把目标最后化简为了一个，就是空目标。

一个重要的定理:

> A tactic can be converted into a solver object using the method `solver()`. If the tactic produces the empty goal, then the associated solver returns `sat`. If the tactic produces a single goal containing `False`, then the solver returns `unsat`. Otherwise, it returns `unknown`.

```python
# 相当于一个组合容器，对自己将要在求解过程中执行的行为进行打包
bv_solver = Then('simplify',
            'solve-eqs',
            'bit-blast',
            'sat').solver()

x,y = BitVecs('x y',16)
solve_using(bv_solver, x | y == 13,x > y)
```

![image-20210220172736970](2021-02-19-Z3GUIDE-MS.assets/image-20210220172736970.png)

> In the example above, the tactic `bv_solver` implements a basic bit-vector solver using equation solving, bit-blasting, and a propositional SAT solver. Note that, the command `Tactic` is suppressed. All Z3Py combinators automatically invoke `Tactic` command if the argument is a string. Finally, the command `solve_using` is a variant of the `solve` command where the first argument specifies the solver to be used.

在这个里面Tactic被隐藏掉了，因为z3py combinators 在输入为string的情况下会自动调用Tactic。

```python
# 当然可以直接显式调用goal组合为的solver的解决功能
bv_solver = Then(With('simplify', mul2concat = True),
                'solve-eqs',
                'bit-blast',
                'aig',
                'sat').solver()
x,y = BitVecs('x y',16)
bv_solver.add(x*32 + y ==13, x & y < 10,y>-100)
print(bv_solver.check())

m = bv_solver.model()
print(x*32+y,"==",m.evaluate(x*32+y))
print(x&y,"==",m.evaluate(x&y))
```

![image-20210220173502381](2021-02-19-Z3GUIDE-MS.assets/image-20210220173502381.png)

```python
# The tactic smt wraps the main solver in Z3 as a tactic. smt可以基本具备主要solver的共呢个

x, y = Ints('x y')
s = Tactic('smt').solver()
s.add(x > y + 1)
print s.check()
print s.model()

```

---

> Now, we show how to implement a solver for integer arithmetic using SAT. The solver is complete only for problems where every variable has a lower and upper bound.

求解整数运算也是可以的，但是需要保证变量有上下边界

with函数可以理解为需要修改部分参数时候需要额外套上的一层外壳

```python
s = Then(With('simplify',arith_lhs = True,som = True),
        'normalize-bounds','lia2pb','pb2bv',
        'bit-blast','sat').solver()
x,y,z = Ints('x y z')

solve_using(s,
        x > 0,x<10,
        y>0,y<10,
        z >0,z<10,
        3*y+2*x==z)

# It fails on the next example(it is unbounded)
s.reset() # 这个是重置条件的函数
solve_using(s,3*y+2*x == z)
```

![image-20210221083004676](2021-02-19-Z3GUIDE-MS.assets/image-20210221083004676.png)

因为下方的例子没有附加边界情况，所以显示fail to solve

---

> Tactics can be combined with solvers. For example, we can apply a tactic to a goal, produced a set of subgoals, then select one of the subgoals and solve it using a solver. The next example demonstrates how to do that, and how to use model converters to convert a model for a subgoal into a model for the original goal.

```python
t = Then('simplify', 'normalize-bounds', 'solve-eqs')

x,y,z = Ints('x y z')
g = Goal()
g.add(x>10,y==x+3,z >3)

# r contains only one subgoal
r = t(g)
print(r)

s = Solver()
s.add(r[0])
print(s.check())

# model for the subgoal
print(s.model())

# model for the original goal
print(r[0].convert_model(s.model())) # 注意运用这个拆分问题得到的r

```

![image-20210221084107936](2021-02-19-Z3GUIDE-MS.assets/image-20210221084107936.png)

注意结果，子问题最后的model为空，根据上面的引理，这个原问题是sat的，最后一行利用转换器转换为本身即可。

由于tutorial上面的例子有点问题，又去文档里找到了出处。

**retrieve model from a satisfiable goal**

> ```
> Retrieve model from a satisfiable goal
> >>> a, b = Ints('a b')
> >>> g = Goal()
> >>> g.add(Or(a == 0, a == 1), Or(b == 0, b == 1), a > b)
> >>> t = Then(Tactic('split-clause'), Tactic('solve-eqs'))
> >>> r = t(g)
> >>> r[0]
> [Or(b == 0, b == 1), Not(0 <= b)]
> >>> r[1]
> [Or(b == 0, b == 1), Not(1 <= b)]
> >>> # Remark: the subgoal r[0] is unsatisfiable
> >>> # Creating a solver for solving the second subgoal
> >>> s = Solver()
> >>> s.add(r[1])
> >>> s.check()
> sat
> >>> s.model()
> [b = 0]
> 
> --- 这里需要额外注意，这里对子问题进行求解 结果中只含有部分参数的值
> 
> >>> # Model s.model() does not assign a value to `a`
> >>> # It is a model for subgoal `r[1]`, but not for goal `g`
> >>> # The method convert_model creates a model for `g` from a model for `r[1]`.
> >>> r[1].convert_model(s.model())
> [b = 0, a = 1]
> 
> ```
>
> 

### Probes

> **Probes** (aka formula measures) [不知道翻译为公式测度 是否合适]are evaluated over goals. Boolean expressions over them can be built using relational operators and Boolean connectives. The tactic `FailIf(cond)` fails if the given goal does not satisfy the condition `cond`. Many numeric and Boolean measures are available in Z3Py. The command `describe_probes()` provides the list of all built-in probes.
>
> ```
> describe_probes()
> ```

In the following example, we build a simple tactic using `FailIf`. It also shows that a probe can be applied directly to a goal.

```python
x, y, z = Reals('x y z')
g = Goal()
g.add(x + y + z > 0)

p = Probe('num-consts')
print "num-consts:", p(g)

t = FailIf(p > 2)
try:
    t(g)
except Z3Exception:
    print "tactic failed"

print "trying again..."
g = Goal()
g.add(x + y > 0)
print t(g)
```

上面这段有点云里雾里的还是p ![image-20210221085746252](2021-02-19-Z3GUIDE-MS.assets/image-20210221085746252.png)

p(g) 对p本身又没有影响，t中加的条件 还是p；

或许可以这么理解，在t中的Failif(p>2)中

p还是一个匿名函数，当如上所示t(g), 将g作为参数输入t函数的时候，实际上是进行了 p(g) > 2 这个条件的判断

---

也提供了很多缩写的策略

Z3Py also provides the combinator (tactical) `If(p, t1, t2)` which is a shorthand for:

```
OrElse(Then(FailIf(Not(p)), t1), t2)
```

The combinator `When(p, t)` is a shorthand for:

```
If(p, t, 'skip')
```

The tactic `skip` just returns the input goal. The following example demonstrates how to use the `If` combinator.

```
x, y, z = Reals('x y z')
g = Goal()
g.add(x**2 - y**2 >= 0)

p = Probe('num-consts')
t = If(p > 2, 'simplify', 'factor')

print t(g)

g = Goal()
g.add(x + x + y + z >= 0, x**2 - y**2 >= 0)

print t(g)
```

![image-20210221091921824](2021-02-19-Z3GUIDE-MS.assets/image-20210221091921824.png)

未知数个数满足条件的时候又因式分解，要不然就化简。

---

## Fixedpoints

这一章比较复杂，较多的引入了关系代数

> This tutorial illustrates uses of Z3's fixedpoint engine. The following papers [μZ - An Efficient Engine for Fixed-Points with Constraints.](http://research.microsoft.com/en-us/people/nbjorner/z3fix.pdf) (CAV 2011) and [Generalized Property Directed Reachability](http://research.microsoft.com/en-us/people/nbjorner/z3pdr.pdf) (SAT 2012) describe some of the main features of the engine.
>
> Please send feedback, comments and/or corrections to [nbjorner@microsoft.com](mailto:nbjorner@microsoft.com).

如上提到了两篇重要论文，在有必要的时候可以去看。

> This tutorial covers some of the fixedpoint utilities available with Z3. The main features are a basic Datalog engine, an engine with relational algebra and an engine based on a generalization of the Property Directed Reachability algorithm.(属性方向可达性算法)

### Basic Datalog

The first example illustrates how to declare relations, rules and how to pose queries.

```python

fp = Fixedpoint()

a,b,c = Bools('a b c')

fp.register_relation(a.decl(),b.decl(),c.decl())
fp.rule(a,b)
fp.rule(b,c)
fp.set(engine= 'datalog')
print("current set of rules\n",fp,"###")
print(fp.query(a))

fp.fact(c)
print("updated set of rules\n",fp,"###")
print(fp.query(a))
print(fp.get_answer())
```

cmd:

![image-20210221093640403](2021-02-19-Z3GUIDE-MS.assets/image-20210221093640403.png)

---

The example illustrates some of the basic constructs.

```
  fp = Fixedpoint()
```

creates a context for fixed-point computation.

创建一个文本箱，来记录定点计算的信息

```
 fp.register_relation(a.decl(), b.decl(), c.decl())
```

Register the relations `a, b, c` as recursively defined.

允许这几个变量的值进行递归处理

```
 fp.rule(a,b)
```

Create the rule that `a` follows from `b`. In general you can create a rule with multiple premises and a name using the format

这个很关键，注意先后顺序，a是follow b的，所以B成立才能a成立。

```
 fp.rule(head,[body1,...,bodyN],name)
```

The *name* is optional. It is used for tracking the rule in derivation proofs. Continuing with the example, `a` is false unless `b` is established.

```
 fp.query(a)
```

Asks if `a` can be derived. The rules so far say that `a` follows if `b` is established and that `b` follows if `c` is established. But nothing establishes `c` and `b` is also not established, so `a` cannot be derived.

```
 fp.fact(c)
```

Add a fact (shorthand for `fp.rule(c,True)`). Now it is the case that `a` can be derived.

#### explanations

> It is also possible to get an explanation for a derived query. For the finite Datalog engine, an explanation is a trace that provides information of how a fact was derived. The explanation is an expression whose function symbols are Horn rules and facts used in the derivation.

也可以获取派生查询的解释。 对于有限的Datalog引擎，解释是一种跟踪，提供有关如何得出事实的信息。 解释是一个表达式，其功能符号是推导中使用的Horn规则和事实。 

```python
fp = Fixedpoint()

a, b, c = Bools('a b c')

fp.register_relation(a.decl(), b.decl(), c.decl())
fp.rule(a,b)
fp.rule(b,c)
fp.fact(c)
fp.set(generate_explanations=True, engine='datalog')
print fp.query(a)
print fp.get_answer()
```

正常来说第九行的参数配置可以让 11行的结果输出配合着一个推导过程，但是我实际运行中进行了报错，不知道是不是由于版本问题还是怎么说

---

Relations can take arguments. We illustrate relations with arguments using edges and paths in a graph.

```python
fp = Fixedpoint()
fp.set(engine='datalog')

s = BitVecSort(3)
edge = Function('edge',s,s,BoolSort())
path = Function('path',s,s,BoolSort())
a = Const('a',s)
b = Const('b',s)
c = Const('c',s)

fp.register_relation(path,edge)
fp.declare_var(a,b,c)
fp.rule(path(a,b),edge(a,b)) #这里，relations 还可以是函数为参数，函数可以继续携带参数。丰富了运算过程
fp.rule(path(a,c),[edge(a,b),path(b,c)])

v1 = BitVecVal(1,s)
v2 = BitVecVal(2,s)
v3 = BitVecVal(3,s)
v4 = BitVecVal(4,s)

fp.fact(edge(v1,v2))
fp.fact(edge(v1,v3))
fp.fact(edge(v2,v4))



print("current set of rules",fp,"###")

print(fp.query(path(v1,v4)),"yes we can reach v4 from v1") # 通过上面的规则定义，这里已经可以判断出可达性

# 而且由于这个是单向的图，所以能保证题意
print(fp.query(path(v3,v4)),"No we can not reach v4 from v3")

```

The example uses the declaration

```
 fp.declare_var(a,b,c)
```

to instrument the fixed-point engine that `a, b, c` should be treated as variables when they appear in rules. Think of the convention as they way bound variables are passed to quantifiers in Z3Py.

---

## Advanced Topics

### Expressions，Sorts and Declarations

> In Z3, expressions, sorts and declarations are called *ASTs*. ASTs are directed acyclic graphs. Every expression has a sort (aka type). The method `sort()` retrieves the sort of an expression.
>
> asts就是说有向无环图

```python
# x,y = Ints('x y')
print(eq(x+y,x+y))
print(eq(y+x,x+y)) # 不相等是由于被强制转化了类型

n = x+y
print(n,x+y)

# x2 is eq to x
x2 = Int('x')

print(eq(x,x2))

print(eq(Int('x'),Real('x')))

```

![image-20210221105240165](2021-02-19-Z3GUIDE-MS.assets/image-20210221105240165.png)

The method `hash()` returns a hashcode for an AST node. If `eq(n1, n2)` returns `True`, then `n1.hash()` is equal to `n2.hash()`.

> Z3 expressions can be divided in three basic groups: **applications**, **quantifiers** and **bounded/free variables**. Applications are all you need if your problems do not contain universal/existential quantifiers. Although we say `Int('x')` is an integer "variable", it is technically an integer constant, and internally is represented as a function application with `0` arguments. Every application is associated with a **declaration** and contains `0` or more arguments. The method `decl()` returns the declaration associated with an application. The method `num_args()` returns the number of arguments of an application, and `arg(i)` one of the arguments. The function `is_expr(n)` returns `True` if `n` is an expression. Similarly `is_app(n)` (`is_func_decl(n)`) returns `True` if `n` is an application (declaration).

变量有的时候会被看作一个无参数的function application。

```python
x = Int('x')
print("is expression: ",is_expr(x))
print(is_app(x))
n = x + 1
print("is application:", is_app(n))
print('decl: ',n.decl()) # 把declaration理解为运算符吗
print("num args: ", n.num_args())
for i in range(n.num_args()):
    print("arg(",i,")->",n.arg(i))
```

![image-20210221110903031](2021-02-19-Z3GUIDE-MS.assets/image-20210221110903031.png)

---

这一章节的内容，我也不知道为什么放到第四板块，主要是很多细节，讲解basic three groups，同时还有不少属性值可以去选用，以更好的来判断情况

> The following example demonstrates how to substitute sub-expressions in Z3 expressions.

```python
x,y = Ints('x y')
f = Function('f', IntSort(), IntSort(), IntSort())
g = Function('g', IntSort(), IntSort())
n = f(f(g(x), g(g(x))), g(g(y)))
print(n)
# subsitute g(g(x)) with y and g(y) with x + 1

print(substitute(n,(g(g(x)),y),(g(y),x+1)))
```

![image-20210221150718735](2021-02-19-Z3GUIDE-MS.assets/image-20210221150718735.png)

### Arrays

> As part of formulating a programme of a mathematical theory of computation McCarthy proposed a *basic* theory of arrays as characterized by the select-store axioms. The expression `Select(a, i)` returns the value stored at position `i` of the array `a`; and `Store(a, i, v)` returns a new array identical to `a`, but on position `i` it contains the value `v`. In Z3Py, we can also write `Select(a, i)` as `a[i]`.

```python
# 注意，都是可以将一些对象写别名的
I = IntSort()
# A is an array from integer to integer
A= Array('A', I, I)

x = Int('x')
print(A[x])
print(Select(A,x))
print(Store(A, x,10))
print(simplify(Select(Store(A,2,x+1),2))) # A[2] 这个位置被存储了x+1这个数据。

```

> y default, Z3 assumes that arrays are extensional over select. In other words, Z3 also enforces that if two arrays agree on all positions, then the arrays are equal.

认定数组是select的扩展，如果两个数组每个位置的内容都相同，则认为这两个数组是相等的

> Z3 also contains various extensions for operations on arrays that remain decidable and amenable to efficient saturation procedures (here efficient means, with an NP-complete satisfiability complexity). We describe these extensions in the following using a collection of examples. Additional background on these extensions is available in the paper [Generalized and Efficient Array Decision Procedures](http://research.microsoft.com/en-us/um/people/leonardo/fmcad09.pdf).

 这些扩展的操作提供了更多应对NP完全问题的方法。

对于无边界与极大的数据，适合用Array，当处理的数据很小且有限时，不建议用Array

```python
# We want an array with 3 elements
# 1. Bad solution
X = Array('x', IntSort(),IntSort())

print(X[0] + X[1] +X[2] >= 0)

# 2. More efficient solution
X = IntVector('x', 3)
print(X[0] + X[1] + X[2] >=0)
print(Sum(X)>=0)
```

![image-20210221204427424](2021-02-19-Z3GUIDE-MS.assets/image-20210221204427424.png)

#### Select and Store

> Let us first check a basic property of arrays. Suppose `A` is an array of integers, then the constraints `A[x] == x, Store(A, x, y) == A` are satisfiable for an array that contains an index `x` that maps to `x`, and when `x == y`. We can solve these constraints.

```python
A = Array('A', IntSort(), IntSort())
x,y = Ints('x y')
solve(A[x] == x, Store(A, x, y)== A)
```



![image-20210221204736293](2021-02-19-Z3GUIDE-MS.assets/image-20210221204736293.png)

#### Constant arrays

> The array that maps all indices to some fixed value can be specified in Z3Py using the `K(s, v)` construct where `s` is a sort/type and `v` is an expression. `K(s, v)` returns a array that maps any value of `s` into `v`. The following example defines a constant array containing only ones.

```python
AllOne = K(IntSort(), 1)
a, i = Ints('a i')
solve(a == AllOne[i])
# The following constraints do not have a solution
# solve(a!= 1, a ==AllOne[i])

solve(a == AllOne[i],a!=1)
# 由此可见，定义类型映射函数在z3中是很方便的
```

### Datatypes

> Algebraic datatypes, known from programming languages such as ML, offer a convenient way for specifying common data structures. Records and tuples are special cases of algebraic datatypes, and so are scalars (enumeration types). But algebraic datatypes are more general. They can be used to specify finite lists, trees and other recursive structures.

### Quantifiers

> Z3 is can solve quantifier-free problems containing arithmetic, bit-vector, Booleans, arrays, functions and datatypes. Z3 also accepts and can work with formulas that use quantifiers. It is no longer a decision procedure for such formulas in general (and for good reasons, as there can be no decision procedure for first-order logic).并且有充分的理由，因为对于一阶逻辑不可能有决策程序

有没有量词，z3都可以应对

```python
f = Function('f', IntSort(), IntSort(), IntSort())
x,y = Ints('x y')
print(ForAll([x,y],f(x,y)==0))
print(Exists(x, f(x, x)>=0))

a,b = Ints('a b')
solve(ForAll(x, f(x, x)==0), f(a,b)==1)
```

![image-20210221210648912](2021-02-19-Z3GUIDE-MS.assets/image-20210221210648912.png)

