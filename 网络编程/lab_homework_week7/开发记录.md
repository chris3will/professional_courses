# 简单文件传输

## 2017141051019 王崇智  

参考：

课程教学代码，FileTransferClient.java, FIleTransferServer.java

****

目前的主项目文件：

MyFTPClient.java, MyFTPServer.java



### 4-11

目前的操作都是线性的，且都是保证不出错的
server端只能保证用户的一次访问即操作请求

功能1： 客户端向服务器端发送文件，在本地借助data流将文件对象以流的形式通过socket向服务器端发送
服务器在本地创建一个文件对象通过fos.write写到本地，并且借助df全局格式化文件大小。

8:41 测试1:
测试客户端功能1的会换请求是否通过
用户可以正常结束单次行为，但是若选择退出，服务器端并未有任何显示输出，即我们未知其是否检测到客户端已退出的动作
-> 意识到一个问题，用户的socket连接为了不出错且保证安全，在单次文件传输的时候，文件传输结束即运行socket.close动作
-> 我要么在launch函数里面加一重循环，添加一个全局变量以表示是否需要重开线程进行二次操作

-> 同时，socketclose之后，data流reader也即同时关闭即使循环操作，

测试点：服务器首次接到用户的文件请求，至少要显示地打印一下名字，且实际上应该有一个过滤器对文件进行筛选，我这里就没有进行操作了。知识在服务器端打印一个名字
-> 完成

问题： 客户端采用多线程的方式会无限开放
-> 局部单线程方式处理

思路： 在客户端程序中将服务器的信息即地址与端口号设置为全局变量即可。我只用读，不涉及抢占的问题
-> 解决效果，直接在Client的新线程里面在结束的时候，需要判断循环之时进行new Thread操作即可。 目前没有设定线程池以对线程进行约束。

问题： 每个线程，它到达svr的时候，没有办法判断是初次到达还是之后的新指令，所以对client的提示语都是一样的。这一点怎么破？
-> 添加一个arrived到达标记即可

15.10 基本可以跑通了
需要加入一些异常检测：
客户端上传文件是否存在
-> 目前忽略字母大小写的问题，实际保存格式按照客户端上传数据为主

错误： 输入一个非法指令之后，选择重启操作后在SVR端会报错
```java
java.lang.NullPointerException
    at MyFTPServer$Waiter.run(MyFTPServer.java:64)
    at java.lang.Thread.run(Thread.java:745)
```
  -> 在client端的1,2之外的状态添加writer.println


****