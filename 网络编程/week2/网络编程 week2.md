# 网络编程 week2

socket在内核空间就是c语言的一个结构体

由结构体中的一个一个元素构成

套接口API让我们可以访问内核，从里面读数据

****

为什么要再加一层socket？

套接口在最开始设计的时候，并不是为了tcp/ip协议栈开发的

****

## why layering

分层带来的好处还是胜过其带来的问题的。

![image-20200304103047581](E:\thridSpring\网络编程\week2\image-20200304103047581.png)

两个buffer就是应用层和tcp传递数据的一个桥梁 ；

至于什么时候被应用层取走，这是要跟实际队列情况有关的

4-tuple用来表示tcpip地址

****

## 分解复用

![image-20200304103300154](E:\thridSpring\网络编程\week2\image-20200304103300154.png)

通讯的进程都是成对出现的；

- 那如何区分来自于网络的数据包要发给哪一个app呢？
  - 利用端口 port

****

## Port 端口

![image-20200304103525660](E:\thridSpring\网络编程\week2\image-20200304103525660.png)

port 80 web sever 一个典型的well-known端口，1~1023共1024个

这个端口号没有什么独特的东西，就纯粹是标记某个具体的进程  

![image-20200304104423276](E:\thridSpring\网络编程\week2\image-20200304104423276.png)

​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               

linux下有一些网络的工具

netcat

nc -l [port]

![image-20200304105404163](E:\thridSpring\网络编程\week2\image-20200304105404163.png)

TCP先把 port分配给了一个进程，UDP可以把相同端口号分配给另一个进程，因为TCP和UDP两的模块分别管理相同数量级范围的端口号，但是二者没有冲突                                                                       

****

##  Endpoint的地址

![image-20200304105712754](E:\thridSpring\网络编程\week2\image-20200304105712754.png)

## 作业

![image-20200304110056828](E:\thridSpring\网络编程\week2\image-20200304110056828.png)

如何实际上实现并利用这个四元组

server进程有recv这样的监听操作，有人定向访问自己，则在其程序中进行记录，并建立绑定关系。因为客户端的进程号是无关紧要的，随机生成一个自己记录并且发出去即可

https://blog.csdn.net/whui19890911/article/details/8695454

由于internet大多采用C/S 模式， 客户机与服务器的通信总是由客户首先发起的，因此只需要让客户机进程实现知道服务器进程的端口号就可以了。而TCP/IP采用了全局分配和静态分配相互结合的方法，即分别为保留端口号和自由端口号两部分。

虽然服务器端的端口号只有一个，但是可以为多个客户机服务，以tcp/IP为例，服务器保留端口号专门监听客户端的连接请求，当服务器从保留端口收到一个连接请求后会立即创建一个县城，并未这个县城分配一个服务器端的自由端口号，然后用这个线程继续与那个客户端通信。



****

## 套接口、套接字、端口

![image-20200304111253986](E:\thridSpring\网络编程\week2\image-20200304111253986.png)

### 套接口

内核中结构体，C语言那个，占用内存空间

并且提供了一套API以供访问

### 端口

进程一启动，就要找tcp给他分配一个唯一的整数标记

![image-20200304111356784](E:\thridSpring\网络编程\week2\image-20200304111356784.png)

- 套接口中包含了进程所绑定的端口号
- 在程序中如何表示一个套接口
- 文件句柄，相当于数组中对应的一个下标

##  TCP 三路握手，从protocol 的角度

![image-20200304112001314](E:\thridSpring\网络编程\week2\image-20200304112001314.png)

- 和应用层基本没有关系；除了发起进程给了TCP一个信号，其他就是两端的TCP独立操作，各自的应用层没有感觉-
- UDP不可靠
- 做的事情
  - 通知双方的initial seq number
  - 接收窗口rwnd（流量控制）

****

![image-20200304113412793](E:\thridSpring\网络编程\week2\image-20200304113412793.png)

注意两个握手的主题对象

两边的两个套接口被初始化完成，才能说明握手成功。

**服务器端和客户端的区别**

1. 双方事先都要完成套接口的创建

2. 服务器端的套接口会被调整为listen状态（只有这个套接口的状态处于监听状态，才可以进行三路握手）

3. server要先初始化自己的套接口四元组。

   1. 多主机服务器有多张网卡，做负载均衡这样的事情。初始化local ip的时候可能会采用通配符来进行填写

   ![image-20200304114923854](E:\thridSpring\网络编程\week2\image-20200304114923854.png)

   这样不同的客户端对服务器进行匹配的时候，都可以被允许而建立连接。

